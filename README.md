# О проекте
Это выполненное тестовое задание — RESTful API для каталога товаров, реализованное с использованием современных технологий Python.

# Общее
Проект использует следующие инструменты и технологии:

* Python: Версия 3.13
* FastAPI: Веб-фреймворк для создания API
* SQLite: База данных (выбрана для упрощения вместо PostgreSQL)
* SQLAlchemy: ORM для работы с базой данных

# Реализованные эндпоинты
API включает следующие эндпоинты:

* ```GET /catalog/``` - Постраничный вывод списка товаров с поиском и фильтрацией
* ```GET /catalog/filter/``` - Вывод параметров для фильтрации
* ```GET /product/{UID}``` - Информация о товаре
* ```POST /product/``` - Добавление товара
* ```DELETE /product/{UID}``` - Удаление товара
* ```POST /properties/``` - Добавление свойства
* ```DELETE /properties/{UID}``` - Удаление свойства

# Структура данных
## Товар
* uid (строка): Уникальный идентификатор
* name (строка): Название товара
* properties (список): Значения свойств товара
## Свойство
  Свойства могут быть числовыми `(int)` или списочными `(list)`. 
  Например, свойство "высота" принимает любое целое число `(int)`, 
  а свойство "объём памяти" имеет предопределённые значения, такие как "1GB", "2GB", "10GB".

* `uid` (строка): Уникальный идентификатор
* `name` (строка): Название свойства
* `type` (строка): Тип свойства (list или int)
* `values` (массив, только для типа list):
  * `value_uid` (строка): Уникальный идентификатор значения
  * `value` (строка): Название значения 

Тестовые данные находятся в файле product_catalog/utils/vacancy.json.

# Описание эндпоинтов
## GET /catalog/
Возвращает список товаров в формате JSON с поддержкой пагинации, фильтрации и сортировки.

### Query-параметры:

* `page` (int, >=1): Номер страницы (по умолчанию 1).
* `page_size` (int, 1-100): Размер страницы (по умолчанию 10).
* `property_<uid>` (строка, опционально): Фильтр по значению свойства (можно указать несколько значений).
* `property_<uid>_from/to` (int, опционально): Фильтр по диапазону числового свойства.
* `name` (строка, опционально): Подстрока для поиска по названию товара.
* `sort` (строка, опционально): Параметр сортировки (name или uid, по умолчанию uid). Сортировка по возрастанию.

Примеры:

* `/catalog/` - Первые 10 товаров, первая страница.
* `/catalog/?name=abc&property_uid1=uid1&property_uid1=uid2&property_uid2=uid3` - Первые 10 товаров, отфильтрованных по свойству uid1 со значениями [uid1, uid2] и свойству uid2 со значением uid3.
* `/catalog/?name=abc&property_uid3_from=10&property_uid3_to=15` - Первые 10 товаров, отфильтрованных по свойству uid3 (тип int) со значениями от 10 до 15.

```json
{
  "products": [
    {
      "uid": "uid1",
      "name": "Товар 1",
      "properties": [
        {"uid": "uid1", "name": "Свойство 1", "value_uid": "uid1", "value": "Значение 1"},
        {"uid": "uid3", "name": "Свойство 3", "value_uid": null, "value": 15}
      ]
    },
    {
      "uid": "uid2",
      "name": "Товар 2",
      "properties": [
        {"uid": "uid1", "name": "Свойство 1", "value_uid": "uid2", "value": "Значение 2"},
        {"uid": "uid3", "name": "Свойство 3", "value_uid": null, "value": 13}
      ]
    }
  ],
  "count": 50
}

```

## GET /catalog/filter/
Возвращает статистику фильтров: общее количество товаров и количество по значениям свойств. Принимает те же query-параметры, что и /catalog/, кроме page и page_size.

### Примеры:

* `/catalog/filter/` - Статистика по всей базе:
```json
{
  "count": 50,
  "property_uid1": {"uid1": 10, "uid2": 15},
  "property_uid2": {"uid3": 20},
  "property_uid4": {"min_value": 10, "max_value": 20}
}
```

## GET /product/{UID}
Возвращает информацию о товаре по его UID в том же формате, что и в /catalog/.

### Пример:

* `GET /product/uid1`
```json
{
  "uid": "uid1",
  "name": "Товар 1",
  "properties": [
    {"uid": "uid1", "name": "Свойство 1", "value_uid": "uid1", "value": "Значение 1"},
    {"uid": "uid3", "name": "Свойство 3", "value_uid": null, "value": 15}
  ]
}
```
Ошибки:
* 404: Если товар не найден.

## POST /product/
Создает новый товар. Формат данных совпадает с выводом в каталоге, но name для свойств и value для списочных свойств не требуются.

Пример запроса:
```json
{
  "uid": "uid1",
  "name": "Товар 1",
  "properties": [
    {"uid": "uid1", "value_uid": "uid1"},
    {"uid": "uid3", "value": 15}
  ]
}
```
Ошибки:

* 400: Если свойство или значение не существует.

## DELETE /product/{UID}
Удаляет товар по UID.

### Пример:

* `DELETE /catalog/product/uid1`

Ошибки:
* 404: Если товар не найден.

## POST /properties/
Создает новое свойство.

Пример запроса для "списка":
```json
{
  "uid": "uid1",
  "name": "Свойство 1",
  "type": "list",
  "values": [
    {"value_uid": "uid1", "value": "Значение 1"},
    {"value_uid": "uid2", "value": "Значение 2"}
  ]
}
```
Пример запроса для "числа":
```json
{
  "uid": "uid2",
  "name": "Свойство 2",
  "type": "int"
}
```
Ошибки:

* 400: Если свойство или значение уже существует.

## DELETE /properties/{UID}
Удаляет свойство по UID, включая связанные значения для типа "список".

### Пример:

* `DELETE /catalog/properties/uid1`

Ошибки:
* 404: Если свойство не найдено.

# Установка и запуск на Linux
#### 1. Клонировать репозиторий
```bash
git clone git@github.com:MaxPositive/product_catalog_test_task.git
cd product_catalog_test_task
```
Либо через ssh
```bash
git clone https://github.com/MaxPositive/product_catalog_test_task.git
cd product_catalog_test_task
```
#### 2. Для ручного запуска есть скрипт run.sh. Скрипт применяет миграции и запускает веб-сервер.
```bash
# Нужно разрешить выполнение скрипта
chmod +x run.sh
./run.sh
```
.env файл уже создан

#### 2.1 Можно запустить через docker, если он у вас установлен
```bash
docker compose up
```